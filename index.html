<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    article {
      width: 300px;
      height: 300px;
      background-color: aqua;
    }

    /*
    css 우선순위
    1.id로 적용한 스타일이 class로 적용한 스타일보다 우선순위가 높음
    2.선택자가 길고 구체적인게 우선순위가 높음
    3.위의 규칙을 무시하고 강제로 우선순위를 높이고 싶을깨에는 속성구문 뒤에 important적용
    4.자바스크립트로 스타일 덮어쓰기 가능
    */
  </style>
</head>

<body>

  <!--
    static DOM (HTML태그로 구성하는 돔)
    dydnamic DOM (자바스크립트로 구성하는 돔)

    <article>

    <a href="#">link</a>

    </article>

    template literal
    : 문자안에 변수를 편하게 삽입할 때
    
  -->
  <ul>
    <li>list1</li>
    <li>list2</li>
    <li>list3</li>
  </ul>

  <ul class="btns">
    <li class="on">button1</li>
    <li>button2</li>
    <li>button3</li>
  </ul>


  <a href="https://www.naver.com" target="_blank" title="네이버 페이지로 이동">네이버</a>



  <script>
    //`<a href='${link}>'링크</a>`

    const url = 'https://www.naver.com';
    const text2 = '네이버'

    //부모프레임.innerHTML = '자식태그 문자열'
    //innerHTML은 기존 프레임안쪽의 값을 없애버리므로 대입되는 문자열로 바꿔치기
    document.body.innerHTML = `
    <article>
    <a href="${url}">${text2}</a>
    </article>
    `

    /*
    const box = document.querySelector('article');
    box.addEventListener('click', () => {
      //자바스크립트는 html외의 css파일에 대한 접근권한이 없으므로 css로 등록되어 있는 스타일 정보값을 가져오는게 불가능
      //결론 = 일반 css에 적용되어 있는 스타일을 가져오기 위해서는 getComputedStyl메서드 사용
      // box.style['background-color'] = 'hotpink';
      // console.dir(box.style);
      //contgetComputedStyle() : 이미 브라우저에 렌더링된 스타일 다시 script로 연산해서 연산된 결과값을 반환

    })

    const link = document.querySelector('a');

    console.log(link.getAttribute('target'));

    const attrInfo = [
      { href: 'https://www.nate.com' },
      { target: '_blank' },
      { title: '네이트 페이지로 이동' },
      { text: '네이트' }

    ]

    const changeAttr = (selector, info) => {
      info.forEach((data) => {
        const key = Object.keys(data)[0];
        const value = Object.values(data)[0];
        console.log('keys');
        console.log('value');
        selector.setAttribute(key, value);
        if (key === 'text') selector.innerText = value;
      })
    }
    changeAttr(link, attrInfo)
*/



    /*원시형자료(primate type) vs 참조형 자료(reference type)
    원시형자료는 메모리에 값자체가 담기는 자료 (문자열, 숫자, boolean. underfined)
    원시형자료는 callstack에 메모리 선언후 값도 담김
    
    참조형자료(배열, 객체, null)
    참조형자료는 메모리에 값이 담겨 담기는게 아닌 값의 참조위치값이 당김
    해당값으로 실행할 수 있는 여러 기능들까지 같이 참조됨
    */
    let num; //변수를 선언 (자바스크립트로 메모리를 생성)
    num = 3; //변수에 값 할당
    let num2 = 5; //변수 초기화(메모리 선언과 동시에 값 할당)
    //let 으로 선언한 변수는 재할당 가능
    const num3 = 5;

    let color = ['red', 'green', 'yellow']
    let color2 = color
    color2[0] = 'hotpink'

    let student1 = {
      name: '이성진',
      age: 19,
      isFemale: false,
      intersts: ['game', 'movie', 'travel']
    }
    let score = null;


    /*전개연산자(Spread Operator)
    기존의 ㅊ참조형 자료들 값을 다 꺼내서 펼친뒤 deep copy*/
    let colors = ['red', 'green', 'blue'];
    let colors2 = [...colors]; // 기존의 참조형 자료값을 꺼내서 deepcopy한 다음에 새로운 변수에 할당
    colors2[0] = 'hotpink';
    console.log(colors)
    console.log(colors2)
    //위와 같이 원본을 훼손하지 않으면서 복사본을 만드는 별변성이 프론트엔드 개발에서 중요한 이유
    //리엑트에서는 원본과 변경됨 복사본이 같이 있어야지 해당 차이점을 인지해서 화면을 변경해줌

    const student2 = {
      name: 'David', // property = (key,value)
      age: 20,
      'is-Female': false //property key에 -입력하면 -라는 연산자로 처리되므로 명시적으로 문자열 처리
    }

    student2.name = 'seongjin'
    //console.log(student2.is-femail);
    //객체에 property에 접근하는 방법
    //객체명.property(key);
    //rorcpaud['property-key']
    console.log(student2['is-Female'])
    console.log(student2)

    //const 변수를 아예 새로운 자려형으로 재할당은 불가능하다

    let name = 'name1';
    //객체의 property key값을 변수로 치환가능



    const obj = {
      [name]: 'Andy'
    }

    console.log(obj.name);

    //외부 서버데이터를 가져와야 하는 경우
    //초기에 변수를 선언하는 해야 되는데 담을 값이 없을 경우

    //객체의 값이 없을때 바로 에러가 뜨면서 다음의 구문이 실행안됨
    //해당 객체의 값이 없을때에는 일단 무시하고 넘어간 뒤 해당값이 있을때 호출
    //optional chainig

    let obj1 = null;

    //특정 변수의 값이 없을때 대체값 할당
    //해당 객체의 없는 property값을 호출하면 바로 에러가 뜨므로
    //일단 optional chaining으로 에러를 무시하고 넘어간 뒤 디폴트값을 대신 적용

    console.log(obj?.name || 'default');

    obj1 = {
      name: 'Andy'
    }

    console.log(obj1.name);

    //비구조화할당, 구조분해할당 (Destructuring)

    const colors3 = ['red', 'green', 'blue'];
    //const colors4 = colors3[0];
    // const colors5 = colors3[1];
    //  const colors6 = colors3[2];
    const [colors4, colors5, colors6] = colors3;
    console.log(colors6);

    const student3 = {
      name1: 'seongjin',
      age: 19,
      address: 'Seoul'
    }
    //객체값을 비구조화할당시에는 무조건 property key명으로만 변수 추출 가능
    //객체의 property명이 아닌 다른 변수로 추출가능
    const { name1, age: age2, address } = student3;
    console.log(age2);

    const studentInfo = [
      { name: 'David', age: 19, hobby: 'hame' },
      { name: 'Emily', age: 20, hobby: 'game' },
      { name: 'DaMichael', age: 21 },
    ]

    //parameter:(매개변수):함수안쪽에 특정 값을 전달하기 위한 통로명
    //argument:(인수):매개변수를 통해서 실체적으로 전달되는 값
    //피라미터의 인수값으로 전달되는 값이 없을때 default parameter 설정가능
    //전달되는 인수값은 객체하나인데 객체안의 property값을 추출해서 내부로 전달

    //총 3개의 인수가 전달
    /*
    function showInfo({ name, age, hobby = '없음' }) {
      console.log(`해당학생의 이름은 ${name}이며 나이는 ${age}입니다. 그리고 취미는 ${hobby}입니다.`)
    }
    showInfo(studentInfo[0])
    showInfo(studentInfo[1])
    showInfo(studentInfo[2])
*/

    const lis = document.querySelectorAll("li");
    console.log(lis);

    //fotEach 순수배열이 아닌 유사배열도 반복사능
    lis.forEach((data) => {
      console.log(data);
    })

    //순수배열만 반복가능;
    //querySelectorALL로 받아지는 배열값은 유사배열이기 때문에 map으로 반복처리 불가능
    //해결방법 -유사배열을 순수배열로 변환
    const newLis = Array.from(lis); //유사배열을 인수로 받아서 순수배열형태로 반환
    newLis.map((data) => {
      console.log(data);
    })
    //for of : 문자를 반복처리
    const text = 'DEVELOPMENT';

    for (let letter of text) {
      console.log(letter);
    }
    //for in : 객체의 key를 반복처리
    const student4 = {
      name: 'David',
      age: 20,
      address: 'Seoul',
      hobby: 'game'
    }
    //for in 반복문에서는 key값을 문자로 반복처리하기 떄문에
    //객체명.key 호출 불가능
    //객체명[key]호출
    for (let key in student4) {
      console.log(student4[key]);
    }


    //es7
    //Object.keys(객체명):배열로 해당 객체의 key를 반환
    //Object.values(객체명):배열로 해당 객체의 values값을 반환
    console.log(Object.keys(student4))
    console.log(Object.values(student4))

    //Object.key로 반환된 배열값 바로 반복처리
    Object.keys(student4).forEach(key => console.log(student4[key]))

    //filter : 기존 배열값의 불변성을 유지하면서 특정조건에 부합되는 새로운 배열을 반환
    const studentDB = [
      { name: 'seongjin', age: 20, 'hobby': 'game' },
      { name: 'emily', age: 18, 'hobby': 'music' },
      { name: 'eunjin', age: 29, 'hobby': 'game' },
      { name: 'gwang', age: 54, }
    ]

    const result = studentDB.map((data) => {
      return data.hobby;
    });
    console.log(result); //['game','music','game','undefined']

    //filter의 인수로 조건식을 넣어서 
    //해당 조건에 부합되는 값만 배열로 변환

    const abc = result.filter(data => data === undefined);
    console.log(abc);


    //hosting : 메모리를 선언하지 않고, 값도 할당하지 않았음에도 불구하고
    //선언되지 않는 메모리를 호출했을 때 해당 값이 맨위로 강제로 끌어올라가져서 값을 호출할 수 있는 현상
    //일반적인 function함수는 호출위치가 자유로움
    const result1 = plus1(3, 4)
    console.log(result);

    function plus1(n1, n2) {
      return n1 + n2;
      console.log(n1 + n2);
    }



    const minus1 = (n1, n2) => {
      return n1 - n2;
    }

    //화살표 함수에서 중괄호와 return 생략가능
    //인수로 2개의 값을 받아서 연산한다음에 리턴하는 함수
    //함수안쪽의 복수줄 이상의 state문이 들어가게 되면 무조건 중괄호로 감싼뒤에 return문으로 처리
    const minus2 = (n1, n2) => (n1 - n2);


    const result2 = minus1(3, 2)
    console.log(result2);



    const returnObject = (name, age) => ({
      name: name,
      age: age
    })

    const student5 = returnObject('seongjin', 19);
    console.log(student5)





    /*
        const hander1 = () => {
          console.log('test')
        }
        const hander2 = (text) => {
          console.log(text)
        }
    
        //이벤트 발생 시 호출할 함수에 인수를 전달할 필요가 없을 때
        btns[0].addEventListener('click', hander1)
        //이벤트 발생 시 호출할 함수에 인수를 전달해야 될 때 다시 화살표함수로 wrapping처리
        btns[1].addEventListener('click', () => hander2('hello'))
    */

    /*
        btns.forEach(btn => {
          //화살표 함수 안쪽의 this객체는 무조건 window객체가 찍힘
          //화살표함수 안쪽에서는 this객체가 아예 생성이 안됨
          //코드를 안쪽에서 this객체가 없을때에는 상위스코프에 있는 끌어옴
          btn.addEventListener('click', (e) => {
            console.log(e.target)
          })
        })
        */
    /*
        btns.forEach(function (btn) {
          //일반 function문으로 이벤트핸들러 연셜시 내부의 this객체는 이벤트가 발생한 대상을 지칭
          //기본 function문으로 호출되는 위치에 따라 내부에 생성되는 this의 값이 변경됨
          //this객체가 임의로 생성되는 function밖에 bind메서드로 원하는 값으로 고정가능
          btn.addEventListener('click', function (e) {
            console.log(this)
          })
        }.bind(this))
    */


  </script>

</body>

</html>