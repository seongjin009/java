<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <ul>
    <li>list1</li>
    <li>list2</li>
    <li>list3</li>
  </ul>




  <script>
    /*원시형자료(primate type) vs 참조형 자료(reference type)
    원시형자료는 메모리에 값자체가 담기는 자료 (문자열, 숫자, boolean. underfined)
    원시형자료는 callstack에 메모리 선언후 값도 담김
    
    참조형자료(배열, 객체, null)
    참조형자료는 메모리에 값이 담겨 담기는게 아닌 값의 참조위치값이 당김
    해당값으로 실행할 수 있는 여러 기능들까지 같이 참조됨
    */
    let num; //변수를 선언 (자바스크립트로 메모리를 생성)
    num = 3; //변수에 값 할당
    let num2 = 5; //변수 초기화(메모리 선언과 동시에 값 할당)
    //let 으로 선언한 변수는 재할당 가능
    const num3 = 5;

    let color = ['red', 'green', 'yellow']
    let color2 = color
    color2[0] = 'hotpink'

    let student1 = {
      name: '이성진',
      age: 19,
      isFemale: false,
      intersts: ['game', 'movie', 'travel']
    }
    let score = null;


    /*전개연산자(Spread Operator)
    기존의 ㅊ참조형 자료들 값을 다 꺼내서 펼친뒤 deep copy*/
    let colors = ['red', 'green', 'blue'];
    let colors2 = [...colors]; // 기존의 참조형 자료값을 꺼내서 deepcopy한 다음에 새로운 변수에 할당
    colors2[0] = 'hotpink';
    console.log(colors)
    console.log(colors2)
    //위와 같이 원본을 훼손하지 않으면서 복사본을 만드는 별변성이 프론트엔드 개발에서 중요한 이유
    //리엑트에서는 원본과 변경됨 복사본이 같이 있어야지 해당 차이점을 인지해서 화면을 변경해줌

    const student2 = {
      name: 'David', // property = (key,value)
      age: 20,
      'is-Female': false //property key에 -입력하면 -라는 연산자로 처리되므로 명시적으로 문자열 처리
    }

    student2.name = 'seongjin'
    //console.log(student2.is-femail);
    //객체에 property에 접근하는 방법
    //객체명.property(key);
    //rorcpaud['property-key']
    console.log(student2['is-Female'])
    console.log(student2)

    //const 변수를 아예 새로운 자려형으로 재할당은 불가능하다

    let name = 'name1';
    //객체의 property key값을 변수로 치환가능



    const obj = {
      [name]: 'Andy'
    }

    console.log(obj.name);

    //외부 서버데이터를 가져와야 하는 경우
    //초기에 변수를 선언하는 해야 되는데 담을 값이 없을 경우

    //객체의 값이 없을때 바로 에러가 뜨면서 다음의 구문이 실행안됨
    //해당 객체의 값이 없을때에는 일단 무시하고 넘어간 뒤 해당값이 있을때 호출
    //optional chainig

    let obj1 = null;

    //특정 변수의 값이 없을때 대체값 할당
    //해당 객체의 없는 property값을 호출하면 바로 에러가 뜨므로
    //일단 optional chaining으로 에러를 무시하고 넘어간 뒤 디폴트값을 대신 적용

    console.log(obj?.name || 'default');

    obj1 = {
      name: 'Andy'
    }

    console.log(obj1.name);

    //비구조화할당, 구조분해할당 (Destructuring)

    const colors3 = ['red', 'green', 'blue'];
    //const colors4 = colors3[0];
    // const colors5 = colors3[1];
    //  const colors6 = colors3[2];
    const [colors4, colors5, colors6] = colors3;
    console.log(colors6);

    const student3 = {
      name1: 'seongjin',
      age: 19,
      address: 'Seoul'
    }
    //객체값을 비구조화할당시에는 무조건 property key명으로만 변수 추출 가능
    //객체의 property명이 아닌 다른 변수로 추출가능
    const { name1, age: age2, address } = student3;
    console.log(age2);

    const studentInfo = [
      { name: 'David', age: 19, hobby: 'hame' },
      { name: 'Emily', age: 20, hobby: 'game' },
      { name: 'DaMichael', age: 21 },
    ]

    //parameter:(매개변수):함수안쪽에 특정 값을 전달하기 위한 통로명
    //argument:(인수):매개변수를 통해서 실체적으로 전달되는 값
    //피라미터의 인수값으로 전달되는 값이 없을때 default parameter 설정가능
    //전달되는 인수값은 객체하나인데 객체안의 property값을 추출해서 내부로 전달

    //총 3개의 인수가 전달
    /*
    function showInfo({ name, age, hobby = '없음' }) {
      console.log(`해당학생의 이름은 ${name}이며 나이는 ${age}입니다. 그리고 취미는 ${hobby}입니다.`)
    }
    showInfo(studentInfo[0])
    showInfo(studentInfo[1])
    showInfo(studentInfo[2])
*/

    const lis = document.querySelectorAll("li");
    console.log(lis);

    //fotEach 순수배열이 아닌 유사배열도 반복사능
    lis.forEach((data) => {
      console.log(data);
    })

    //순수배열만 반복가능;
    //querySelectorALL로 받아지는 배열값은 유사배열이기 때문에 map으로 반복처리 불가능
    //해결방법 -유사배열을 순수배열로 변환
    const newLis = Array.from(lis); //유사배열을 인수로 받아서 순수배열형태로 반환
    newLis.map((data) => {
      console.log(data);
    })
    //for of : 문자를 반복처리
    const text = 'DEVELOPMENT';

    for (let letter of text) {
      console.log(letter);
    }
    //for in : 객체의 key를 반복처리
    const student4 = {
      name: 'David',
      age: 20,
      address: 'Seoul',
      hobby: 'game'
    }
    //for in 반복문에서는 key값을 문자로 반복처리하기 떄문에
    //객체명.key 호출 불가능
    //객체명[key]호출
    for (let key in student4) {
      console.log(student4[key]);
    }


    //es7
    //Object.keys(객체명):배열로 해당 객체의 key를 반환
    //Object.values(객체명):배열로 해당 객체의 values값을 반환
    console.log(Object.keys(student4))
    console.log(Object.values(student4))

    //Object.key로 반환된 배열값 바로 반복처리
    Object.keys(student4).forEach(key => console.log(student4[key]))

    //filter : 기존 배열값의 불변성을 유지하면서 특정조건에 부합되는 새로운 배열을 반환
    const studentDB = [
      { name: 'seongjin', age: 20, 'hobby': 'game' },
      { name: 'emily', age: 18, 'hobby': 'music' },
      { name: 'eunjin', age: 29, 'hobby': 'game' },
      { name: 'gwang', age: 54, }
    ]

    const result = studentDB.map((data) => {
      return data.hobby;
    });
    console.log(result); //['game','music','game','undefined']

    //filter의 인수로 조건식을 넣어서 
    //해당 조건에 부합되는 값만 배열로 변환

    const abc = result.filter(data => data === undefined);
    console.log(abc);
  </script>

</body>

</html>